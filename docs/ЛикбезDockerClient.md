# Ликбез: Docker Registry API v2 (pull-only)

## Минимальные эндпоинты
- `/v2/` (ping + auth): проверяем доступность реестра; на 401 читаем `WWW-Authenticate` (Bearer `realm`, `service`, `scope`), после получения токена повторяем запрос. Ответ 200 без тела означает, что API доступен.
- `/v2/{name}/manifests/{ref}`: `GET` манифеста по тегу/диджесту. Получаем JSON манифеста (OCI или Docker v2) со списком слоёв и config; заголовок `Docker-Content-Digest` должен совпасть с хешем тела. `HEAD` возвращает только заголовки, чтобы быстро проверить наличие/медиатайп/диджест.
- `/v2/{name}/blobs/{digest}`: `GET` слоя/конфига по digest. В ответе бинарный слой/конфиг, можно использовать `Range` для докачки. Проверяем `Content-Length` и соответствие SHA256 указанному digest. `HEAD` — быстрый пруф существования/размера.

## Кэш токенов
- Ключ кэша: `(realm, service, scope, creds)`:
  - `realm`: URL токен-эндпоинта из `WWW-Authenticate`.
  - `service`: идентификатор реестра (также из `WWW-Authenticate`).
  - `scope`: права, обычно `repository:{name}:pull` (может быть несколько через пробел).
  - `creds`: учётные данные запроса (логин/пароль или токен для basic).
- TTL: из `expires_in`; если отсутствует — дефолт короткий (например 5–10 минут). Обновляем по 401.
- Хранение: в памяти процесса (LRU/TTL). Файловый кэш токенов не используем — небезопасно. При нескольких инстансах — опционально распределённый кэш (например Redis с TLS).

## Поведение клиента (ключевые моменты)
- При запросе: сначала токен из кэша; если нет/просрочен — запрашиваем новый и кладём в кэш с TTL.
- Скоупы: типично `repository:{name}:pull`; могут быть несколько scp в `scope` — учитывать в ключе/кэше.
- Валидация: для манифеста сверяем `Docker-Content-Digest`; для blob — пересчитываем SHA256.
- Сетевые политики: таймауты, ретраи только для идемпотентных GET, backoff; `Range` для возобновления скачивания.

## API-шаги скачивания образа
1) `GET /v2/` — получить параметры аутентификации (401 → `WWW-Authenticate`) и убедиться, что реестр жив.
2) `GET /v2/{name}/manifests/{ref}` — забрать манифест по тегу/диджесту, понять список слоёв и config.
3) Для каждого digest из манифеста: `GET /v2/{name}/blobs/{digest}` — скачать слои и config (можно параллелить; при обрыве — `Range`).
4) После скачивания — валидация SHA256 и сохранение в кэш/передача в runtime/P2P слой.
